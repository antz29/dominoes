var	// Regular expressions
	/** @const */ R_DELIM = /\s+/,
	
	// Symbols
	SYMBOLS = {},
	/** @const */ SYM_WAIT =		1,
	/** @const */ SYM_READY =		2,
	/** @const */ SYM_BEGIN =		3,
	/** @const */ SYM_END =			4,
	/** @const */ SYM_BEGIN_OPT =	5,
	/** @const */ SYM_END_OPT =		6,
	
	// Miscellaneous
	symbolsArray = "0 > >| ( ) (( ))".split( R_DELIM ),
	i = symbolsArray[ STR_LENGTH ];

// Initialize symbols
while ( --i ) {
	SYMBOLS[ symbolsArray[ i ] ] = i;
}

// Parse a chain
function parseChain( chain ) {
	
	chain = chain.split( R_DELIM );
	
	var i = 0,
		length = chain[ STR_LENGTH ],
		stack = [],
		root = [],
		current = root,
		tmp,
		item;
	
	current.P = TRUE;
	
	for( ; i < length ; i++ ) {
		
		if ( item = chain[ i ] ) {
		
			if ( SYMBOLS[ item ] ) {
			
				item = SYMBOLS[ item ];
			
				if ( item === SYM_WAIT || item === SYM_READY ) {
					
					if ( item === SYM_READY ) {
						current[ STR_PUSH ]( ready );
					}
					
					if ( current[ STR_LENGTH ] ) {
						
						tmp = current.splice( 0 , current[ STR_LENGTH ] );
						tmp.P = current.P; 
						current[ STR_PUSH ]( tmp , [] );
						current.P = FALSE;
						current = current[ 1 ];
						current.P = TRUE;
						
					}
					
				} else if ( item === SYM_BEGIN || item === SYM_BEGIN_OPT ) {
					
					tmp = [];
					current[ STR_PUSH ]( tmp );
					stack[ STR_PUSH ]( current );
					current = tmp;
					current.P = TRUE;
					current.O = item === SYM_BEGIN_OPT;
					
				} else if ( item === SYM_END || item === SYM_END_OPT ) {
					
					if ( stack[ STR_LENGTH ] ) {
						current = stack.pop();
					} else {
						error( "unexpected symbol" , chain[i] );
					}
				}
					
			} else {
			
				current[ STR_PUSH ]( item );
				
			}
		}
		
	}
		
	return root;
}

// Parse a string item
function parseStringItem( string , context , thread ) {

	var done,
		func,
		data = {},
		id = 0,
		tmp;
		
	function parseTemp( string ) {
		
		tmp = /^ { ([0-9]+) } $/.exec( string );
		
		return tmp ? data[ 1 * tmp[ 1 ] ] : string.replace( / { ([0-9]+) } /g , function( _ , key ) {
			
			tmp = data[ 1 * key ];
			
			if ( ! isString( tmp ) ) {
				error( "type mismatch" , "string expected" );
			}

			return tmp;
			
		} );
		
	}
	
	while ( ! done ) {
	
		done = TRUE;
		
		string = string.replace( /\$([^$()]*)\(([^$()]*)\)/g , function( _ , name , args ) {
			
			done = FALSE;
			
			if ( name && ! ( func = predefined(name) || functor( name ) ) ) {
				error( "unknown functor" , name );
			}
			
			args = parseTemp( args );
			
			if ( isString( args ) ) {
				args = parse ( args , context , thread );
			}
			
			data[ ++ id ] = name ? func[ STR_CALL ]( context , args , thread ) : property( args );
			
			if ( isString( data[ id ] ) ) {
				data[ id ] = parse( data[ id ] , context , thread );
			}
			
			return " { " + id + " } ";
			
		});
	}
	
	return parseTemp( string );
}

// Parse a string
function parse( string , context , thread ) {
	
	var parsed;
	
	if ( R_DELIM.test( string ) ) {
		
		parsed = parseChain( string );
		
	} else if ( parsed = context[ string ] || rule( string ) ) {
			
		parsed = isString( parsed ) ? parse( parsed , context , thread ) : parsed;
			
	} else {
		
		parsed = parseStringItem( string , context , thread );
			
	}
	
	return parsed;
}

